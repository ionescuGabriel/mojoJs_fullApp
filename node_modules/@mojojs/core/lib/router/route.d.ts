import type { Router } from '../router.js';
import type { AnyArguments, MojoAction, RouteArguments } from '../types.js';
import { Pattern } from './pattern.js';
/**
 * Route class.
 */
export declare class Route {
    /**
     * The children of this route, used for nesting routes.
     */
    children: Route[];
    /**
     * Custom route name, if defined.
     */
    customName: string | undefined;
    /**
     * Default route name.
     */
    defaultName: string | undefined;
    /**
     * Allow `under` semantics for this route.
     */
    underRoute: boolean;
    /**
     * Restrict HTTP methods this route is allowed to handle, defaults to no restrictions.
     */
    methods: string[];
    /**
     * Pattern for this route.
     */
    pattern: Pattern;
    /**
     * Activate conditions for this route.
     */
    requirements: Array<Record<string, any>>;
    /**
     * Activate `websocket` semantics for this route.
     */
    websocketRoute: boolean;
    _parent: WeakRef<Route> | undefined;
    _root: WeakRef<Router> | undefined;
    /**
     * Add a child to this route.
     */
    addChild(child: Route): Route;
    /**
     * Generate route matching any of the listed HTTP request methods or all.
     * @example
     * // Route with pattern and destination
     * route.any('/user').to('User#whatever');
     *
     * // Route with HTTP methods, pattern, restrictive placeholders and destination
     * route.any(['DELETE', 'PUT'], '/:foo', {foo: /\w+/}).to('Foo#bar');
     *
     * // Route with pattern, name and destination
     * route.any('/:foo').name('foo_route').to('Foo#bar');
     *
     * // Route with pattern, condition and destination
     * route.any('/').requires({agent: /Firefox/}).to('Foo#bar');
     *
     * // Route with pattern and a closure as destination
     * route.any('/:foo', async ctx => ctx.render({text: 'Hello World!'}));
     */
    any(...args: AnyArguments): Route;
    /**
     * Generate route matching only `DELETE` requests.
     * @example
     * // Route with destination
     * route.delete('/user').to('User#remove');
     */
    delete(...args: RouteArguments): Route;
    /**
     * Generate route matching only `GET` requests.
     * @example
     * // Route with destination
     * route.get('/user').to('User#show');
     */
    get(...args: RouteArguments): Route;
    /**
     * Check if this route has a WebSocket ancestor and cache the result for future checks.
     */
    hasWebSocket(): boolean;
    /**
     * Check if this route qualifies as an endpoint.
     */
    isEndpoint(): boolean;
    /**
     * The name of this route, defaults to an automatically generated name based on the route pattern. Note that the name
     * `current` is reserved for referring to the current route.
     */
    name(name: string): this;
    /**
     * Generate route matching only `OPTIONS` requests.
     * @example
     * // Route with destination
     * route.options('/user').to('User#overview');
     */
    options(...args: RouteArguments): Route;
    /**
     * The parent of this route.
     */
    get parent(): Route | undefined;
    set parent(parent: Route | undefined);
    /**
     * Generate route matching only `PATCH` requests.
     * @example
     * // Route with destination
     * route.patch('/user').to('User#update');
     */
    patch(...args: RouteArguments): Route;
    /**
     * Generate route matching only `POST` requests.
     * @example
     * // Route with destination
     * route.post('/user').to('User#create');
     */
    post(...args: RouteArguments): Route;
    /**
     * Generate route matching only `PUT` requests.
     * @example
     * // Route with destination
     * route.put('/user').to('User#replace');
     */
    put(...args: RouteArguments): Route;
    /**
     * Remove route from parent.
     */
    remove(): this;
    /**
     * Render route with parameters into a path.
     */
    render(values?: {}): string;
    /**
     * Activate conditions for this route. Note that this automatically disables the routing cache, since conditions are
     * too complex for caching.
     */
    requires(condition: string, requirement: Record<string, any>): this;
    /**
     * Return the `Router` object this route is a descendant of.
     */
    get root(): Router | undefined;
    set root(root: Router | undefined);
    /**
     * Suggested HTTP method for reaching this route, `GET` and `POST` are preferred.
     */
    suggestedMethod(): string;
    /**
     * Set default parameters for this route.
     */
    to(...targets: Array<string | MojoAction | Record<string, any>>): this;
    /**
     * Generate route for a nested route with its own intermediate destination.
     * @example
     * // Intermediate destination and prefix shared between two routes
     * const auth = app.under('/user').to('User#auth');
     * auth.get('/show').to('User#show');
     * auth.post('/create').to('User#create');
     */
    under(...args: AnyArguments): Route;
    /**
     * Generate route matching only WebSocket handshake requests.
     * @example
     * // Route with destination
     * app.websocket('/echo').to('Example#echo');
     */
    websocket(...args: RouteArguments): Route;
    _branch(): Array<Router | Route>;
}
